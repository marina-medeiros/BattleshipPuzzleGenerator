#include <iostream> // std::cout, std::endl
#include <string>
#include <sstream>
#include <cstdlib> 

#include "include/bpg.h"
#include "include/common.h"

namespace bpg{

/**
 * @brief Generates the next location in the puzzle grid.
 * 
 * This function calculates the next location in the puzzle grid based on the current location and the puzzle object.
 * 
 * @param current The current location in the puzzle grid.
 * @param pz The puzzle object containing information about the puzzle grid.
 * @return The next location in the puzzle grid.
 */
Cell Generator::nextLocation(const Cell& current, Puzzle &pz) {
    Cell next_loc{ current };
    next_loc.col = (next_loc.col + 1) % pz.puzzleCols;
    if (next_loc.col == 0) {
      next_loc.row++;
    }
    return next_loc;
}

/**
 * @brief Generates a key for the puzzle.
 * 
 * This function generates a key for the provided puzzle object.
 * The key is generated by concatenating the characters representing 
 * each cell in the puzzle board.
 * 
 * @param pz The puzzle object for which the key is generated.
 */
  void Generator::generatePuzzleKey(Puzzle &pz) {
    std::string key;
    std::stringstream ss;

    for (short ii = 0; ii < pz.puzzleRows; ii++) {
        for (short jj = 0; jj < pz.puzzleCols; jj++) {
            ss << Puzzle::cellToChar(pz.puzzleBoard[ii][jj]);
        }
        // Append the contents of the stringstream to key after each row
        key += ss.str();
        // Clear the stringstream for the next iteration
        ss.str("");
    }

    pz.puzzleKey = key;
}

 
/**
 * @brief Generates auxiliary puzzles recursively.
 * 
 * This function is a helper function for generating puzzles recursively. 
 * It starts with a given index and iteratively generates new puzzles by adding ships 
 * and exploring different ship orientations. It continues this process until all 
 * puzzles are generated or the specified number of puzzles is reached.
 * 
 * @param index The index of the ship being placed.
 * @param pz The puzzle object for which auxiliary puzzles are generated.
 * @param pzKeys A set containing keys of generated puzzles.
 * @param opt The running options determining the generation process.
 * @param puzzleList The list of generated puzzles.
 */
  void Generator::generateAux(int index, Puzzle &pz, std::set<std::string> &pzKeys, const RunningOpt &opt, std::list<Puzzle> &puzzleList){
    pz.puzzleShips[index].shipHeadCell = Cell(0, 0);
    pz.puzzleShips[index].shipChange_or = true;

    while(pz.puzzleShips[index].shipHeadCell != pz.endLocation){
      pz.puzzleShips[index].shipPlaced = pz.addShip(pz.puzzleShips[index]);
      if (not pz.puzzleShips[index].shipPlaced) {
          pz.puzzleShips[index].shipHeadCell = Generator::nextLocation(pz.puzzleShips[index].shipHeadCell, pz);
          continue;
      }

      if(index >= 9){
          bool all_placed = true;
          for(int i = 0; i < 10; i++){
              if(not pz.puzzleShips[i].shipPlaced){
                  all_placed = false;
              }
          }
          if(all_placed){
            generateArmada(pz);
            generatePuzzleKey(pz);
            if(pzKeys.find(pz.puzzleKey) == pzKeys.end()){
              pzKeys.insert(pz.puzzleKey); 
              puzzleList.push_back(pz);
            }
            if(static_cast<int>(pzKeys.size()) == opt.n_puzzles){
              return;
            }
          }
      }
      else{
          if(puzzleList.size() == opt.n_puzzles){
            return;
          }
          generateAux((index+1), pz, pzKeys, opt, puzzleList);
      }

      pz.removeShip(pz.puzzleShips[index]);
      if (pz.puzzleShips[index].shipChange_or) {
      pz.puzzleShips[index].shipChange_or = false;
      if (pz.puzzleShips[index].shipOrientation == Ship::orientation::H) {
          pz.puzzleShips[index].shipOrientation = Ship::orientation::V;
      }
      continue;
      }
      pz.puzzleShips[index].shipHeadCell = Generator::nextLocation(pz.puzzleShips[index].shipHeadCell, pz);
      pz.puzzleShips[index].shipOrientation = Ship::orientation::H;
      pz.puzzleShips[index].shipChange_or = true;
    }
  }

/*
 * @brief Generates a list of puzzles based on the provided options.
 * 
 * This function generates a list of puzzles according to the provided
 * running options. It uses recursion to create
 * new puzzles by adding ships and exploring different ship orientations.
 * 
 * @param opt The running options determining the generation process.
 * @return A list of generated puzzles.
 */
  std::list<Puzzle> Generator::generate(const RunningOpt &opt){
    Puzzle pz(opt.cols, opt.rows);
    std::set<std::string> pzKeys;
    std::list<Puzzle> puzzleList;

    pz.puzzleShips[0].shipChange_or = true;
    while (pz.puzzleShips[0].shipHeadCell != pz.endLocation) {
      pz.puzzleShips[0].shipPlaced = pz.addShip(pz.puzzleShips[0]);

      generateAux(1, pz, pzKeys, opt, puzzleList);

      pz.removeShip(pz.puzzleShips[0]);
      if (pz.puzzleShips[0].shipChange_or) {
      pz.puzzleShips[0].shipChange_or = false;
      if (pz.puzzleShips[0].shipOrientation == Ship::orientation::H) {
          pz.puzzleShips[0].shipOrientation = Ship::orientation::V;
      }
      continue;
      }
      pz.puzzleShips[0].shipHeadCell = Generator::nextLocation(pz.puzzleShips[0].shipHeadCell, pz);
      pz.puzzleShips[0].shipOrientation = Ship::orientation::H;
      pz.puzzleShips[0].shipChange_or = true;
    }

    return puzzleList;
  }

/**
 * @brief Generates the armada configuration for the puzzle.
 * 
 * This function generates the armada configuration for the given puzzle by
 * concatenating information about each ship type, its position, and orientation.
 * 
 * @param pz The puzzle object for which the armada configuration is generated.
 */
  void Generator::generateArmada(Puzzle &pz) {
    char ship_char[6] = {'W', 'B', 'D', 'C', 'S', 'U'};
    //char ship_orient[2] = { 'H', 'V'};
    std::stringstream ss;

    for (int j=0; j< int(pz.puzzleShips.size()); j++){

        // Concatena todas as coisas em uma única string usando múltiplas operações de inserção
      ss << ship_char[int(pz.puzzleShips[j].shipType)] << ' ' << pz.puzzleShips[j].shipHeadCell.row << ' ' << pz.puzzleShips[j].shipHeadCell.col << ' ';
      if (ship_char[int(pz.puzzleShips[j].shipType)] != ship_char[4]){
        ss << static_cast<char>(pz.puzzleShips[j].shipOrientation)  << '-';
      }else{
        ss << '-';
      }
    }
    pz.puzzleArmada = ss.str();
  }

}